@page "/author"

@using System.IO;
@using Tewr.Blazor.FileReader;
@using Microsoft.CST.OAT;
@using Microsoft.CST.OAT.Blazor.Components.Inputs;
@using Newtonsoft.Json
@using Newtonsoft.Json.Converters
@inject Microsoft.CST.AttackSurfaceAnalyzer.Cli.AppData AppState;
@inject IFileReaderService fileReaderService;
@inject IJSRuntime JSRuntime

<h4>Author</h4>

<div class="container-fluid bg-custom my-1 pb-1">
    <div class="run-box bg-custom">
        <h5>Load in JSON serialized rules.</h5>
        <FileUpload ProcessFile="LoadRules" ReadLabel="Load Rules" ClearAction="ClearRules" ClearLabel="Clear Rules" />
        <hr />
        <button class="btn btn-primary" @onclick="AddRule">Add Rule</button>
        <button class="btn btn-primary" @onclick="RemoveLastRule" disabled=@removeDisabled>Remove Last Rule</button>
        <button class="btn btn-primary" @onclick="ValidateRules">Validate Rules</button>
        <button class="btn btn-primary" @onclick="DownloadRules">Export Rules to JSON</button>
        <button class="btn btn-primary" @onclick="LoadDefaultRules">Load Embedded Rules</button>
    </div>

    @if (issues.Values.Any(x => x.Any()))
    {
        <div>❌ @issues.Values.Count(x => x.Any()) issue(s) detected. Rules are individually labelled with the relevant issue.</div>        
    }
    else
    {
        <div>✔ No issues detected with rules.</div>
    }

    @foreach (var rule in AppState.RulesFile.Rules)
    {
        <div>
            @if (issues.ContainsKey(rule))
            {
                @foreach (var problem in issues[rule])
                {
                    <div>
                        <span class="oi oi-warning"></span>
                        @problem.Description
                    </div>
                }
                @if (issues[rule].Any())
                {
                    <br/>
                }
            }
            else
            {
                <p>Processing Issues for Rule...</p>
            }

            <AsaRuleInput Rule="rule" Types="Types"/>
        </div>
    }
</div>

@code
{

    void ClearRules()
    {
        AppState.RulesFile.Rules.Clear();
        this.StateHasChanged();
    }

    public bool removeDisabled => AppState.RulesFile.Rules.Count == 0;

    Func<Stream, Task> LoadRules = (Stream streamIn) => { return new Task(() => { }); };

    void RefreshPage()
    {
        this.StateHasChanged();
    }

    public void LoadDefaultRules()
    {
        AppState.RulesFile = RuleFile.LoadEmbeddedFilters();
        ValidateRules();
    }

    public async void DownloadRules()
    {
        if (!_serializerSettings.Converters.Any(x => x is StringEnumConverter))
        {
            _serializerSettings.Converters.Add(new StringEnumConverter());
        }
        await JSRuntime.InvokeAsync<object>(
            "FileSaveAs",
            "Asa-Rules.json",
            "data:text/plain;charset=utf-8,",
            Newtonsoft.Json.JsonConvert.SerializeObject(AppState.RulesFile, _serializerSettings)
        );
    }

    Type[] Types = typeof(AsaRule).Assembly.DefinedTypes.Where(x => typeof(CollectObject).IsAssignableFrom(x)).ToArray();

    Analyzer analyzer = new Analyzer();

    JsonSerializerSettings _serializerSettings = new JsonSerializerSettings()
    {
        MissingMemberHandling = MissingMemberHandling.Ignore,
        NullValueHandling = NullValueHandling.Ignore,
        DefaultValueHandling = DefaultValueHandling.Ignore,
        Formatting = Formatting.Indented
    };

    void SetLoadRules()
    {
        LoadRules = async stream =>
        {
            try
            {
                using var sr = new StreamReader(stream);
                var RulesFile = Newtonsoft.Json.JsonConvert.DeserializeObject<RuleFile>(await sr.ReadToEndAsync(), _serializerSettings);
                AppState.RulesFile = RulesFile ?? new RuleFile();
            }
            catch (OperationCanceledException)
            {
                await InvokeAsync(StateHasChanged);
                await Task.Delay(1);
            }
            catch (Exception e)
            {
                var message = e.Message;
                var stackTrace = e.StackTrace;
                var type = e.GetType();
                var name = type.Name;
                type = e.GetType();
                Console.WriteLine(e.Message);
            }
            ValidateRules();
        };
    }

    protected override void OnInitialized()
    {
        SetLoadRules();
        ValidateRules();
        OAT.Utils.Strings.Setup();
        base.OnInitialized();
    }

    Dictionary<AsaRule, IEnumerable<Violation>> issues = new Dictionary<AsaRule, IEnumerable<Violation>>();

    void ValidateRules()
    {
        issues.Clear();
        foreach (var rule in AppState.RulesFile.Rules)
        {
            issues[rule] = analyzer.EnumerateRuleIssues(rule);
        }
        this.StateHasChanged();
    }

    void RemoveLastRule()
    {
        if (AppState.RulesFile.Rules.Count > 0)
        {
            AppState.RulesFile.Rules.RemoveAt(AppState.RulesFile.Rules.Count - 1);
        }
        ValidateRules();
    }

    void AddRule()
    {
        AppState.RulesFile.Rules.Add(new AsaRule("Rule Name Here"));
        ValidateRules();
    }
}